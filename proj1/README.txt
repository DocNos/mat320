# MAT 320 Project 1 - Complex Number Operations with Roots of Unity

**Author:** Nixx Varboncoeur  
**Course:** MAT 320 - Digital Signal Processing  
**Instructor:** Matt Klassen  

## Overview

This C++ command-line program performs complex number operations involving roots of unity, supporting four distinct mathematical operations commonly used in digital signal processing.

## Project Structure

mat320/proj1/
├── src/
│   ├── main.cpp                 # Command-line interface with executable name detection
│   ├── complex_operations.h     # Class definitions and function declarations
│   └── complex_operations.cpp   # Implementation of all four operations
├── input/                       # Input test files
│   ├── f1.txt                   # Instructor test file 1
│   └── f2.txt                   # Instructor test file 2
├── output/                      # Expected output files (generated by Makefile)
├── bin/                         # Compiled executables
│   ├── complex_calc             # Combined executable (all parts)
│   ├── rot                      # Individual Part 1 executable (rotation)
│   ├── sum                      # Individual Part 2 executable (sum of unity)
│   ├── dot                      # Individual Part 3 executable (inner product)
│   └── prod                     # Individual Part 4 executable (DFT component)
├── obj/                         # Object files (generated during build)
├── claudeLog/                   # AI collaboration session logs
│   ├── session_001_2025-01-14.md
│   └── session_002_2025-01-15.md
├── Makefile                     # Build system with comprehensive testing
├── README.txt                   # This file
└── tests.txt                    # Instructor-provided test cases

## Features

### Part 1: Complex Number Rotation
Rotates N complex numbers by angle 2πx, where:
- x > 0: counterclockwise rotation
- x < 0: clockwise rotation

**Combined Usage:** `./bin/complex_calc 1 N x input/f1.txt`  
**Individual Usage:** `./bin/rot N x input/f1.txt`

### Part 2: Sum of Powers of Roots of Unity
Calculates: 1 + e^(i2π/N) + (e^(i2π/N))² + ... + (e^(i2π/N))^(k-1)

**Combined Usage:** `./bin/complex_calc 2 N k`  
**Individual Usage:** `./bin/sum N k`

### Part 3: Complex Inner Product
Computes the complex inner product of two vectors from input files.

**Combined Usage:** `./bin/complex_calc 3 N input/f1.txt input/f2.txt`  
**Individual Usage:** `./bin/dot N input/f1.txt input/f2.txt`

### Part 4: DFT Component
Calculates the inner product of an input vector with the roots of unity vector:
(1, e^(i2π/N), (e^(i2π/N))², ..., (e^(i2π/N))^(N-1))

**Combined Usage:** `./bin/complex_calc 4 N input/f1.txt`  
**Individual Usage:** `./bin/prod N input/f1.txt`

## Building and Running

### Prerequisites
- C++17 compatible compiler (g++)
- Make build system

### Build Commands
make                    # Build release version
make debug             # Build with debug symbols
make build-parts       # Build individual executables (rot, sum, dot, prod)
make rot               # Build rot executable (Part 1)
make sum               # Build sum executable (Part 2)  
make dot               # Build dot executable (Part 3)
make prod              # Build prod executable (Part 4)
make clean             # Remove build and test files
make distclean         # Full cleanup including directories


### Generate Test Files
make test-files                  # Create input and output files
make generate-test-files         # Create input test files
make generate-instructor-files   # Create instructor test files (f1.txt, f2.txt)
make generate-output            # Create expected output files

### Testing
make test              # Run all comprehensive tests
make test-basic        # Run basic tests only
make test-instructor   # Run instructor-provided test cases
make test1             # Test Part 1 (rotation) only
make test2             # Test Part 2 (sum of powers) only
make test3             # Test Part 3 (inner product) only
make test4             # Test Part 4 (DFT component) only

## Input File Format

Complex numbers should be formatted as:
1.0 + 2.0i
-3.5 - 1.2i
0.0 + 4.0i

## Output Format

Results are displayed in the same format as input:
2.0 + 1.0i
-1.2 - 3.5i
4.0 + 0.0i

## Examples

### Example 1: Rotation
# Combined executable: Rotate 2 complex numbers by π/2 (90° counterclockwise)
./bin/complex_calc 1 2 0.25 input/f1.txt
# Individual executable: Rotate 2 complex numbers from f1.txt by π/2
./bin/rot 2 0.25 input/f1.txt

### Example 2: Sum of Powers
# Combined executable: Sum first 5 powers of 8th root of unity
./bin/complex_calc 2 8 5
# Individual executable: Sum first 2 powers of 4th root of unity
./bin/sum 4 2

### Example 3: Inner Product
# Combined executable: Inner product of two 3-element vectors
./bin/complex_calc 3 3 input/vec1.txt input/vec2.txt
# Individual executable: Inner product of f1.txt and f2.txt
./bin/dot 2 input/f1.txt input/f2.txt

### Example 4: DFT Component
# Combined executable: DFT component of 4-element signal
./bin/complex_calc 4 4 input/signal.txt
# Individual executable: DFT component of f1.txt
./bin/prod 2 input/f1.txt

## AI Disclosure

This project was developed with assistance from Claude Code extension for debugging and code optimization support.